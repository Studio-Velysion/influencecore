// Schéma Prisma (production) — PostgreSQL
// Objectif: utiliser PostgreSQL (ex: Coolify, Supabase, Docker) via DATABASE_URL.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String?
  pseudo        String?
  avatar        String?
  links         String?   // JSON stocké comme texte en SQLite
  isAdmin       Boolean   @default(false) @map("is_admin")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  videoIdeas    VideoIdea[]
  videoScripts  VideoScript[]
  quickNotes    QuickNote[]
  userRoles     UserRole[]
  subscriptions UserSubscription[]
  invoices     Invoice[]
  payments      Payment[]
  errorLogs     ErrorLog[]

  @@map("users")
}

model VideoIdea {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  title       String
  concept     String?
  platform    String?
  format      String?
  status      String   @default("Idée")
  priority    String?
  targetDate  DateTime? @map("target_date")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  scripts     VideoScript[]

  @@map("video_ideas")
}

model VideoScript {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  videoIdeaId String?  @map("video_idea_id")
  title       String
  content     String   // JSON stocké comme texte en SQLite
  checklist   String?  // JSON stocké comme texte en SQLite
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  videoIdea   VideoIdea? @relation(fields: [videoIdeaId], references: [id], onDelete: SetNull)

  @@map("video_scripts")
}

model QuickNote {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  content   String
  tag       String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("quick_notes")
}

model Role {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  isSystem    Boolean   @default(false) @map("is_system")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  permissions RolePermission[]
  userRoles   UserRole[]

  @@map("roles")
}

model Permission {
  id          String    @id @default(uuid())
  key         String    @unique
  name        String
  description String?
  category    String?
  createdAt   DateTime  @default(now()) @map("created_at")

  rolePermissions RolePermission[]

  @@map("permissions")
}

model RolePermission {
  id           String   @id @default(uuid())
  roleId       String   @map("role_id")
  permissionId String   @map("permission_id")
  createdAt    DateTime @default(now()) @map("created_at")

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@map("role_permissions")
}

model UserRole {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  roleId    String   @map("role_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

model SubscriptionPlan {
  id          String    @id @default(uuid())
  name        String
  slug        String    @unique
  description String?
  price       String    // Decimal stocké comme String en SQLite
  currency    String    @default("EUR")
  interval    String    @default("month")
  features    String?   // JSON stocké comme texte
  permissions String?   // JSON stocké comme texte - Liste des permissions accordées par ce plan
  isActive    Boolean   @default(true) @map("is_active")
  isUnlimited Boolean   @default(false) @map("is_unlimited")
  displayOrder Int      @default(0) @map("display_order")
  stripePriceId String? @unique @map("stripe_price_id")
  stripeProductId String? @map("stripe_product_id")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  discounts   SubscriptionDiscount[]
  subscriptions UserSubscription[]

  @@map("subscription_plans")
}

model SubscriptionDiscount {
  id          String    @id @default(uuid())
  planId      String?   @map("plan_id") // Nullable pour permettre les codes promo globaux
  code        String    @unique // Code promo unique (ex: SUMMER2024)
  name        String
  description String?
  type        String    // percentage, fixed
  value       String    // Decimal stocké comme String (ex: "10" pour 10% ou "50" pour 50€)
  isActive    Boolean   @default(true) @map("is_active")
  validFrom   DateTime? @map("valid_from")
  validUntil  DateTime? @map("valid_until")
  maxUses     Int?      // Nombre maximum d'utilisations (null = illimité)
  currentUses Int       @default(0) @map("current_uses")
  oneTimePerClient Boolean @default(false) @map("one_time_per_client") // Une seule fois par client
  applicableToFirstPayment Boolean @default(true) @map("applicable_to_first_payment") // Applicable au premier paiement
  applicableToRenewals Boolean @default(false) @map("applicable_to_renewals") // Applicable aux renouvellements
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  plan SubscriptionPlan? @relation(fields: [planId], references: [id], onDelete: Cascade)
  subscriptions UserSubscription[]

  @@map("subscription_discounts")
}

model UserSubscription {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  planId      String    @map("plan_id")
  status      String    @default("active") // active, paused, cancelled, expired, suspended
  isUnlimited Boolean   @default(false) @map("is_unlimited")
  pricePaid   String?   @map("price_paid")
  discountId   String?   @map("discount_id")
  startedAt   DateTime  @default(now()) @map("started_at")
  expiresAt   DateTime? @map("expires_at")
  nextBillingDate DateTime? @map("next_billing_date")
  cancelledAt DateTime? @map("cancelled_at")
  suspendedAt DateTime? @map("suspended_at")
  pausedAt    DateTime? @map("paused_at")
  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  stripeCustomerId    String? @map("stripe_customer_id")
  stripePriceId       String? @map("stripe_price_id")
  stripePaymentIntentId String? @map("stripe_payment_intent_id")
  currentPeriodStart  DateTime? @map("current_period_start")
  currentPeriodEnd    DateTime? @map("current_period_end")
  cancelAtPeriodEnd   Boolean   @default(false) @map("cancel_at_period_end")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan     SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Restrict)
  discount SubscriptionDiscount? @relation(fields: [discountId], references: [id], onDelete: SetNull)
  invoices Invoice[]

  @@map("user_subscriptions")
}

// Modèle Facture (inspiré de BoxBilling Invoice)
model Invoice {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  subscriptionId String?  @map("subscription_id")
  number        String   @unique // Numéro de facture unique (ex: INV-2024-001)
  status        String   @default("draft") // draft, sent, paid, unpaid, overdue, cancelled, refunded
  subtotal      String   // Montant HT (Decimal stocké comme String)
  tax           String   @default("0") // TVA/Taxes
  discount      String   @default("0") // Réduction appliquée
  total         String   // Montant TTC
  currency      String   @default("EUR")
  dueDate       DateTime @map("due_date") // Date d'échéance
  paidAt        DateTime? @map("paid_at")
  sentAt        DateTime? @map("sent_at")
  cancelledAt   DateTime? @map("cancelled_at")
  refundedAt    DateTime? @map("refunded_at")
  notes         String?  // Notes internes
  notesPublic   String?  @map("notes_public") // Notes visibles par le client
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription UserSubscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  items        InvoiceItem[]
  payments     Payment[]

  @@map("invoices")
}

// Modèle Ligne de Facture (inspiré de BoxBilling InvoiceItem)
model InvoiceItem {
  id          String   @id @default(uuid())
  invoiceId  String   @map("invoice_id")
  type        String   @default("custom") // custom, order, deposit, hook_call
  title       String
  description String?
  quantity    String   @default("1") // Decimal stocké comme String
  unitPrice   String   @map("unit_price") // Prix unitaire
  total       String   // Total de la ligne (quantity * unitPrice)
  orderId     String?  @map("order_id") // Si type = order, référence à une commande
  task        String?   // void, activate, renew (pour les items de type order)
  status      String?   // pending_payment, pending_setup, executed
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@map("invoice_items")
}

// Modèle Paiement (inspiré de BoxBilling Payment Transaction)
model Payment {
  id            String   @id @default(uuid())
  invoiceId     String   @map("invoice_id")
  userId        String   @map("user_id")
  amount        String   // Montant payé (Decimal stocké comme String)
  currency      String   @default("EUR")
  method        String   // stripe, paypal, bank_transfer, credit, etc.
  type          String   @default("payment") // payment, refund, subscription_create, subscription_cancel
  status        String   @default("pending") // pending, completed, failed, refunded, unknown
  transactionId String?  @unique @map("transaction_id") // ID de transaction externe (Stripe, PayPal, etc.)
  gateway       String?  // Nom du gateway de paiement
  gatewayTransactionId String? @map("gateway_transaction_id") // ID transaction du gateway
  metadata      String?  // JSON stocké comme texte (données supplémentaires)
  errorMessage  String?  @map("error_message") // Message d'erreur si échec
  processedAt   DateTime? @map("processed_at")
  refundedAt    DateTime? @map("refunded_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
}

// Modèle pour les logs d'erreurs
model ErrorLog {
  id          String   @id @default(uuid())
  level       String   @default("error") // error, warning, info
  message     String
  stack       String?  // Stack trace de l'erreur
  context     String?  // JSON stocké comme texte (contexte supplémentaire)
  userId      String?  @map("user_id")
  userAgent   String?  @map("user_agent")
  url         String?  // URL où l'erreur s'est produite
  method      String?  // Méthode HTTP (GET, POST, etc.)
  statusCode  Int?     @map("status_code") // Code de statut HTTP
  ipAddress   String?  @map("ip_address")
  resolved    Boolean  @default(false) // Si l'erreur a été résolue
  resolvedAt  DateTime? @map("resolved_at")
  resolvedBy  String?  @map("resolved_by") // ID de l'admin qui a résolu
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([level])
  @@index([createdAt])
  @@index([resolved])
  @@map("error_logs")
}

// --- Synchronisation (panneaux externes) ---
// Ces tables permettent de conserver un miroir "InfluenceCore" des données externes (Helpdesk/FOSSBilling)
// tout en gardant les dashboards externes intacts.

model ExternalTicket {
  id          String   @id @default(uuid())
  provider    String   @default("helpdesk") // helpdesk
  externalId  String   @unique @map("external_id")
  subject     String
  description String?
  status      String?  // open/closed/etc (selon helpdesk)
  requesterEmail String? @map("requester_email")
  raw         String?  // JSON brut
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@index([provider])
  @@map("external_tickets")
}

model ExternalSubscription {
  id          String   @id @default(uuid())
  provider    String   @default("fossbilling") // fossbilling
  externalId  String   @unique @map("external_id")
  status      String?
  clientEmail String?  @map("client_email")
  planName    String?  @map("plan_name")
  raw         String?  // JSON brut
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@index([provider])
  @@map("external_subscriptions")
}

